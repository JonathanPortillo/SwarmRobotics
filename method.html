<!DOCTYPE HTML>
<!--
	Industrious by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<title>Decentralized Swarm Robotics</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<meta name="description" content="" />
		<meta name="keywords" content="" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">


		<!-- Header -->
			<header id="header">
				<a class="logo" href="index.html">Decentralized Swarm Robotics</a>
				<nav>
					<a href="#menu">Menu</a>
				</nav>
			</header>

		<!-- Nav -->
			<nav id="menu">
				<ul class="links">
					<li><a href="index.html">Home</a></li>
					<li><a href="introduction_background.html">Introduction/Background</a></li>
					<li><a href="method.html">Method</a></li>
					<li><a href="results.html">Results</a></li>
					<li><a href="conclusion_future_work.html">Conclusion/Future Work</a></li>
				</ul>
			</nav>

		<!-- Banner -->
			

		<!-- Main Component-->
			<section class="wrapper">
				<div class="inner">
					<header class="special">
						<h2>Method</h2>
						<p>
							<p>In this paper, we implement Wang and Rubenstein’s algorithm where a decentralized swarm of <span class="math inline">\(n\)</span> identical robots, represented by set <span class="math inline">\(A\)</span>, is controlled from their initial positions to an arbitrary target formation represented by <span class="math inline">\(Q\)</span>, the set of goal coordinates, using collision-free and deadlock-free paths. For this paper we assume <span class="math inline">\(|A| = |Q|\)</span>.</p>
							<p>Each agent <span class="math inline">\(a_{i} \in A\)</span> is modeled as a circle with radius <span class="math inline">\(r\)</span>. There are three main methods by which the agents operate: motion planner, new goal selector, and broadcaster. The motion planner continuously checks for messages from the agent’s neighbors at intervals of <span class="math inline">\(\Delta t\)</span>. It then checks for a valid space to move to and moves the agent. We assume that each agent has the same clock frequency <span class="math inline">\(f_{clock}\)</span> and velocity <span class="math inline">\(v\)</span>.</p>
							<p>The new goal selector continuously sends and receives requests to swap goals with neighbors which helps prevent deadlock and ensures fast convergence. It uses a 2-way swap in which an agent acts as a client and another acts as a server. The client sends a swap request to the server and the server can either accept or deny the request.</p>
							<p>The third method, broadcaster, enables the agents to communicate with each other. Each agent communicates its state with negligible latency and communication error to all robots within a communication range <span class="math inline">\(R &gt; 2\sqrt{2}r\)</span> at a fixed rate <span class="math inline">\(f_{comm}\)</span>. To ensure collision-free paths, we enforce <span class="math inline">\(\Delta t = 2/f_{comm}\)</span>. We define <span class="math inline">\(p_{a_{i}}(t)\)</span> as the position of <span class="math inline">\(a_i\)</span> at time <span class="math inline">\(t\)</span>. Similarly, <span class="math inline">\(T_{a_{i}}(t)\)</span> is the position assigned to <span class="math inline">\(a_i\)</span> at time <span class="math inline">\(t\)</span>.</p>
							<p>Deadlock-free paths are defined as those where no two robots are assigned the same target position once all robots are guaranteed to be at their assigned position. This is formally defined below by Equation 1: <span class="math inline">\(\exists t_{max} &gt; 0 \ \text{ s.t.} \ \forall t &gt; t_{max}, \ \forall a_{i} \in A, p_{a_{i}}(t) = T_{a_{i}}(t) \text{and} \ \forall a_i \neq a_j, T_{a_{i}}(t) \neq T_{a_{j}}(t)\)</span></p>
							<p>Collision free paths, as the name suggests, are those in which the robots never collide. This is formally defined below by Equation 2: <span class="math inline">\(\forall t \geq 0, {} \mbox{for any two agents, } a_i \neq a_j , \Vert p_{a_i}(t) - p_{a_j}(t) \Vert \geq 2r\)</span></p>
							<p>Furthermore, we make a novel contribution to their work in the form of an extension of their algorithm to the case of a continuous state space.</p></p>
					</header>
					<div class="w3-center"> 
						<img class = "w3-content w3-margin w3-card w3-small" height= "200" width="200" src="images/method1.png" alt="" />
						<img class = "w3-card w3-margin w3-small" height= "200" width="200" src="images/method2.png" alt="" />
						<img class = "w3-card w3-margin w3-small" height= "200" width="200" src="images/method3.png" alt="" />
						<img class = "w3-card w3-margin w3-small" height= "200" width="200" src="images/method4.png" alt="" />
				
					</div>
					<div class="highlights">
						<section>
							<div class="content">
								<header>
									
									<h3>Motion Planner</h3>
								</header>
								<p><p>The first part that needed to be changed was the receiving of messages by the motion planner. Since we did not have the hardware necessary for receiving broadcasts from neighboring robots, we developed an artificial broadcasting mechanism in which each agent <span class="math inline">\(a_i\)</span> had its own instance variable <span class="math inline">\(msg_i\)</span> containing the message that it would "broadcast" at the current time. Every agent would check its neighbors by iterating through the entire set of robots and choosing the ones who were within a range <span class="math inline">\(R\)</span> (the communication range) and store its message variable. Also, the algorithm required all messages from the past <span class="math inline">\(\Delta t\)</span> seconds to be taken. Since, <span class="math inline">\(\Delta t\)</span> was very small in comparison to agent message updates, we kept sampling the most recent message from all neighboring agents for <span class="math inline">\(\Delta t\)</span> seconds. We kept the final set of messages and continued the algorithm. Additionally, <span class="math inline">\(2/f_{comm}\)</span> was a very small time interval compared to the latency in the context switching required by multi-threading. Thus, we empirically chose <span class="math inline">\(\Delta t\)</span> to be <span class="math inline">\(180/f_{comm}\)</span> where <span class="math inline">\(f_{comm} = 200\)</span></p></p>
							</div>
						</section>
						<section>
							<div class="content">
								<header>
	
									<h3>New Goal Selector</h3>
								</header>
								<p><p>The new goal selector was altered so that goal swapping could occur safely without race conditions. This was particularly important in the 2-way swaps. Swap requests for each agent were kept in a list of requests stored as a variable for each agent. Since a server could have multiple requests, there needed to be a secure way for clients to add their request to the server’s list without causing a race condition with another client trying to swap with the same server. Thus, two kinds of locks were implemented, a request lock (<span class="math inline">\(REQ\)</span>) and an acknowledgement lock (<span class="math inline">\(ACK\)</span>).</p>
								<p>Each request list had an <span class="math inline">\(REQ\)</span> and every agent had an <span class="math inline">\(ACK\)</span>. Thus, if a client wanted to send a request to a server, it would need to obtain the corresponding <span class="math inline">\(REQ\)</span>, add its request to the list, and release the <span class="math inline">\(REQ\)</span>. The server would obtain its <span class="math inline">\(REQ\)</span> and look through the list of requests for a client who it wants to swap goals with. If such a client was there, then the server would obtain the client’s <span class="math inline">\(ACK\)</span>, send the client its goal, and release the <span class="math inline">\(ACK\)</span>. Otherwise, it would just ignore the requests (the request would be removed after a timeout interval by the client itself). Then the server would release the <span class="math inline">\(REQ\)</span> after looking through its requests. This proved to be an easy and effective way of simulating 2-way requests between multiple clients and a server.</p></p>
							</div>
						</section>
						<section>
							<div class="content">
								<header>
									<h3>Broadcaster</h3>
								</header>
								<p><p>To simulate broadcasting signals from a physical system at a fixed rate of <span class="math inline">\(f_{comm}\)</span>, we set each agent’s variable <span class="math inline">\(msg_i\)</span> to the current state of the agent and then had the method sleep for <span class="math inline">\(1/f_{comm}\)</span> seconds.</p></p>

								<header>
									<h3>Extension into Continuous Domain</h3>
								</header>
								<p>With the basic algorithm established by Wang and Rubenstein simulated, we moved on to simulating the algorithm in the continuous domain. This required some more modification to allow the same convergence properties in the continuous domain.</p>
								<p>The first modification was to choose an appropriate distance metric. While we used manhattan distance in the discrete grid setup, we switched to the L2-norm distance metric in the continuous setup. This allowed for a better approximation of the distance between points.</p>
								<p>The second modification was to choose a different way of traversing through the space. We couldn’t just have up, down, left, and right as candidate spots for the next step. Thus, we used a polar coordinate design for stepping through the space. Each robot would be able to move the same distance per step (same radial distance) but would have the choice of the angle it could move at. We found that the more choices of angles the robot had, the slower the algorithm would be. Thus, we empirically found a resolution of 16 candidate angles to be feasible in the runtime of the algorithm.</p>
							</div>
						</section>
				</div>
			</section>

		

		<!-- About Us -->
			<section class="wrapper">
				<div class="inner">
					<header class="special">
						<h2>About Us</h2>
					</header>
					<div class="testimonials">
						<section>
							<div class="content">
								<blockquote>
									<p>EECS 2020</p>
								</blockquote>
								<div class="author">
									<div class="image">
										<img src="images/pic01.jpg" alt="" />
									</div>
									<p class="credit">- <strong>Jonathan Portillo</strong> </p>
								</div>
							</div>
						</section>
						<section>
							<div class="content">
								<blockquote>
									<p>Input Major / Year</p>
								</blockquote>
								<div class="author">
									<div class="image">
										<img src="images/pic03.jpg" alt="" />
									</div>
									<p class="credit">- <strong>Varun Jhunjhunwalla</strong> </p>
								</div>
							</div>
						</section>
						<section>
							<div class="content">
								<blockquote>
									<p>Input Major / Year</p>
								</blockquote>
								<div class="author">
									<div class="image">
										<img src="images/pic02.jpg" alt="" />
									</div>
									<p class="credit">- <strong>Shreyas Agarwal</strong> </p>
								</div>
							</div>
						</section>
					</div>
				</div>
			</section>

		<!-- Footer -->
			<footer id="footer">
				<div class="inner">
					<div class="content">
						<section>
							<h3>Accumsan montes viverra</h3>
							<p>Nunc lacinia ante nunc ac lobortis. Interdum adipiscing gravida odio porttitor sem non mi integer non faucibus ornare mi ut ante amet placerat aliquet. Volutpat eu sed ante lacinia sapien lorem accumsan varius montes viverra nibh in adipiscing. Lorem ipsum dolor vestibulum ante ipsum primis in faucibus vestibulum. Blandit adipiscing eu felis iaculis volutpat ac adipiscing sed feugiat eu faucibus. Integer ac sed amet praesent. Nunc lacinia ante nunc ac gravida.</p>
						</section>
						<section>
							<h4>Sem turpis amet semper</h4>
							<ul class="alt">
								<li><a href="#">Dolor pulvinar sed etiam.</a></li>
								<li><a href="#">Etiam vel lorem sed amet.</a></li>
								<li><a href="#">Felis enim feugiat viverra.</a></li>
								<li><a href="#">Dolor pulvinar magna etiam.</a></li>
							</ul>
						</section>
						<section>
							<h4>Magna sed ipsum</h4>
							<ul class="plain">
								<li><a href="#"><i class="icon fa-twitter">&nbsp;</i>Twitter</a></li>
								<li><a href="#"><i class="icon fa-facebook">&nbsp;</i>Facebook</a></li>
								<li><a href="#"><i class="icon fa-instagram">&nbsp;</i>Instagram</a></li>
								<li><a href="#"><i class="icon fa-github">&nbsp;</i>Github</a></li>
							</ul>
						</section>
					</div>
					<div class="copyright">
						&copy; Untitled. Photos <a href="https://unsplash.co">Unsplash</a>, Video <a href="https://coverr.co">Coverr</a>.
					</div>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script src="https://www.w3schools.com/lib/w3.js"></script>
			<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  			<script id="MathJax-script" async
          	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
          	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">

	</body>
</html>