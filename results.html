<!DOCTYPE HTML>
<!--
	Industrious by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<title>Decentralized Swarm Robotics</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<meta name="description" content="" />
		<meta name="keywords" content="" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a class="logo" href="index.html">Decentralized Swarm Robotics</a>
				<nav>
					<a href="#menu">Menu</a>
				</nav>
			</header>

		<!-- Nav -->
			<nav id="menu">
				<ul class="links">
					<li><a href="index.html">Home</a></li>
					<li><a href="introduction_background.html">Introduction/Background</a></li>
					<li><a href="method.html">Method</a></li>
					<li><a href="results.html">Results</a></li>
					<li><a href="conclusion_future_work.html">Conclusion/Future Work</a></li>
					<li><a href="references.html">References</a></li>
				</ul>
			</nav>

		<!-- Banner -->


		<!-- Highlights -->
			<section class="wrapper">
				<div class="inner">
					<header class="special">
						<h2>Results</h2>

					</header>

						<section>
							<div class="content">
								<header>

									<h3>Number of agents</h3>
								</header>
								<p><p>The first experiment we ran was to understand how the size of the swarm affects the performance of the algorithm. We used two metrics to judge the performance: total distance traveled by the robots <span class="math inline">\(TDT\)</span> and time taken to converge. We were confident that time taken and <span class="math inline">\(TDT\)</span> would increase as the number of agents increased since more agents would lead to more path-planning, goal assignment and overall computation. However, we noticed an interesting result in [1] where the algorithm’s performance suddenly improves (i.e. the total time and <span class="math inline">\(TDT\)</span> decreases) as the number of agents is increased. Specifically, the performance of the algorithm for  196 agents is far better than the performance for 25 to 169 and 225 to 529 agents.</p>
						<p>We performed the same experiment with our implementation, averaging results over 6 trials per swarm size. The results are shown in Figure 1. As expected, we see an overall increase in the runtime and distance travelled as the number of robots increases. We also see the previously mentioned improvement when using five agents. On visualizing these trials on our simulator we noticed some behaviors that might be causing this anomaly. When the number of agents is too high, the number of agents sharing the same goal is larger, causing a large number of ’wait-flags’, leading to increased runtime. There is also excess travel when the robots try to swap goals and form clusters of cyclic ’traffic graphs’ which are further discussed in Section IV.C. When the number of agents is too small, the performance is good but two or three robots can hardly be called a swarm. The strange behavior of four agents showing a worse performance than five can be explained through certain behaviors identified in the simulations as well. The four agent case specifically demonstrates a strange behavior where two or three agents form a cluster in adjacent squares and alternate between swapping goals and moving back and forth. This behavior accounts for the worse performance, but can actually be controlled by decreasing the probability of swapping goals in the goal manager. Further experimentation is needed to understand the extent to which this parameter can affect performance.</p></p>
						<img src="images/g1_rr.png" alt="" />
						<img src="images/g2_td.png" alt="" />
							</div>
						</section>
						<section>
							<div class="content">
								<header>

									<h3>Continuous vs Discrete Experimentation</h3>
								</header>
								<p>
									<p>We compared our discrete space implementation to our continuous space modification. We ran the discrete version for runtimes of 10, 20, and 30 seconds each and recorded <span class="math inline">\(TDT\)</span>, initial distance (<span class="math inline">\(IDT\)</span>), distance to convergence (<span class="math inline">\(DTC\)</span>), percent of initial distance completed (<span class="math inline">\(PDC\)</span>), and efficiency (<span class="math inline">\(EFF\)</span>). We conducted this experiment 20 times and present here the average of the 20 trials. For the continuous case we tested runtimes of 50, 100, and 150 seconds since the continuous version took a longer time to run. We recorded the same data and conducted the experiment 10 times with the average being presented here. <span class="math inline">\(IDT\)</span> is the sum of the distances between each robot and the nearest available goal state. <span class="math inline">\(DTC\)</span> is the same as initial distance except after the time allotted for the simulation has elapsed. <span class="math inline">\(PDC\)</span> completed is <span class="math inline">\(1 - DTC/IDT\)</span> expressed as a percentage. This gives a measure for how close the system is to convergence compared to the starting configuration. This gives a good metric as we are able to compare states that start close to convergence as well as those that start far from convergence on equal footing. <span class="math inline">\(EFF\)</span> is <span class="math inline">\(IDT/(TDT + DTC)\)</span>. This allows us to compare how the estimated total distance traveled (<span class="math inline">\(TDT + DTC\)</span>) compares to the initial distance of the starting configuration.</p>
									<p>As can be seen in Table 1, the <span class="math inline">\(TDT\)</span> of the discrete setting is higher than <span class="math inline">\(TDT\)</span> of the continuous setting (up to 5 times more). We can also see the differences in <span class="math inline">\(PDC\)</span> and <span class="math inline">\(EFF\)</span> between the two settings. <span class="math inline">\(PDC\)</span> for discrete is a lot higher than <span class="math inline">\(PDC\)</span> for continuous. This corresponds to the fact that more computation must be done in the continuous setting causing the runtime to be a lot larger. However, we can see that as runtime increases, <span class="math inline">\(EFF\)</span> of the discrete setting drops below that of the continuous setting. With larger runtime, the discrete setting requires agents to explore the grid more and take exaggerated paths around each other. However, in the continuous case, the <span class="math inline">\(EFF\)</span> remains approximately the same and is higher than the discrete setting. However, this is comparing discrete and continuous settings in different cases where the continuous setting is given a lot more time to converge. Thus, we conducted another experiment to test discrete and continuous settings at the same level.</p></p>
									<img src="images/graph_2.png" alt="" />
							</div>
						</section>
						<section>
							<div class="content">
								<header>

									<h3>Continuous vs Discrete Analysis</h3>
								</header>
								<p><p>We ran experiments to compare the performance of our continuous space planner with that of the discrete planner where both settings are allowed a maximum runtime of 150 seconds. Figure 2 compares these algorithms with data averaged over 35 trials. Figure 2(a) shows a familiar results, with the red line following a similar trend as the previously discussed Figure 1(a). The blue shows the biggest con of using the continuous version, high running time. As discussed before, this is expected since the continuous version is sampling an exponentially larger number of goals and potential paths than the discrete version. It also faces more behavioral issues such a deadlocks due to an incomplete characterization of the L2-norm distance metric.</p>
								<p>Figure 2(b), on the other hand, shows the benefits of using the continuous algorithm. The total distance traveled by the swarm before convergence is much lower in the continuous case as the swarm isn’t restricted to Manhattan paths. While this does increase the runtime, it finds a more optimal path to the goals than [1]. The rate of increase in distance traveled with the swarm size is also worth noting. The discrete swarms face more complexity as the size increases since the number of possible collision paths is comparable to the total number of paths. This problem is not prominent in the continuous case as there are infinite possible paths.</p>
								<p>Figure 3(c) shows the effect of swarm size on efficiency. As swarm size increases, the efficiency drops for both continuous and discrete cases drops. This is because with more robots, the agents swap goals more often and tend to explore more before convergence. Thus, <span class="math inline">\(TDT + DTC\)</span> tends to increase with larger swarm size. However, around a swarm size of 5 to 7 robots, the continuous case has an efficiency equaling or exceeding that of the discrete case. The time saved in moving directly to the goal becomes more useful with a larger swarm size.</p></p>
								<img src="images/size_time.png" height="50%" width=60% alt="" />
								<img src="images/size_tdt.png" height="50%" width=60% alt="" />
								<img src="images/size_eff.png" height="50%" width=60% alt="" />
							</div>
						</section>

					</div>
			</section>



		<!-- About Us -->
			<section class="wrapper">
				<div class="inner">
					<header class="special">
						<h2>About Us</h2>
					</header>
					<div class="testimonials">
						<section>
							<div class="content">
								<blockquote>
									<p>EECS / 2020</p>
								</blockquote>
								<div class="author">
									<div class="image">
										<img src="images/jonathan.jpg" alt="" />
									</div>
									<p class="credit">- <strong>Jonathan Portillo</strong> </p>
								</div>
							</div>
						</section>
						<section>
							<div class="content">
								<blockquote>
									<p>EECS / 2021</p>
								</blockquote>
								<div class="author">
									<div class="image">
										<img src="images/varun.jpg" alt="" />
									</div>
									<p class="credit">- <strong>Varun Jhunjhunwalla</strong> </p>
								</div>
							</div>
						</section>
						<section>
							<div class="content">
								<blockquote>
									<p>EECS / 2021</p>
								</blockquote>
								<div class="author">
									<div class="image">
										<img src="images/shreyas.png" alt="" />
									</div>
									<p class="credit">- <strong>Shreyas Agarwal</strong> </p>
								</div>
							</div>
						</section>
					</div>
				</div>
			</section>

		<!-- Footer -->
			<footer id="footer">
				<div class="inner">
					<div class="content">

						<section>
							<h4>Project Repository</h4>
							<ul class="plain">
								<li><a href="https://github.com/robot1230/EE106B_final_proj"><i class="icon fa-github">&nbsp;</i>Github</a></li>
							</ul>
						</section>
					</div>
					<div class="copyright">
						&copy; Untitled. Photos <a href="https://unsplash.co">Unsplash</a>, Video <a href="https://coverr.co">Coverr</a>.
					</div>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script src="https://www.w3schools.com/lib/w3.js"></script>
			<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  			<script id="MathJax-script" async
          	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
          	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">

	</body>
</html>
